---
import type { Post, LinkedMention } from '@/types';
import { findLinkedMentions } from '@/utils/internallinks';
import { getCollection } from 'astro:content';
import { getFeature, siteConfig } from '@/config';
import Icon from './Icon.astro';

export interface Props {
  currentSlug: string;
}

const { currentSlug } = Astro.props;
const isCompact = (siteConfig.postOptions.linkedMentions as any).linkedMentionsCompact;

// Get all posts and pages to find linked mentions
const posts = await getCollection('posts');
const pages = await getCollection('pages');
const linkedMentions = findLinkedMentions(posts as any[], currentSlug, posts as any[], pages as any[]);


// Function to process links in excerpt text
function processExcerptLinks(text: string, targetSlug: string): string {
  // First, process wikilinks - keep brackets but bold only the relevant link
  text = text.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (match, link, display) => {
    // Parse anchor if present
    const anchorIndex = link.indexOf('#');
    const baseLink = anchorIndex === -1 ? link : link.substring(0, anchorIndex);
    
    // Process the link to get the slug for comparison
    let linkSlug = baseLink.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
    
    // Handle posts/path format
    if (baseLink.startsWith('posts/')) {
      const postPath = baseLink.replace('posts/', '');
      // For folder-based posts, remove /index to get the folder name (slug)
      const cleanPath = postPath.endsWith('/index') ? postPath.replace('/index', '') : postPath;
      linkSlug = cleanPath.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
    }
    
    // Special case: if the link is just display text (no path), check if it matches the target post title
    // This handles cases where markdown links are converted to wikilinks in excerpts
    let isRelevantLink = linkSlug === targetSlug;
    
    if (!isRelevantLink && !baseLink.includes('/') && !baseLink.includes('posts/')) {
      // This is likely a display text that was converted from a markdown link
      // Check if this display text matches the target post title
      const targetPost = posts.find(p => p.slug === targetSlug);
      if (targetPost) {
        const titleSlug = targetPost.data.title.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
        isRelevantLink = linkSlug === titleSlug;
        
        // Debug logging removed for production
      }
    }
    
    if (isRelevantLink) {
      // For relevant links, create the proper wikilink format and highlight it
      // If there's a display override, use [[display]], otherwise use [[link]]
      const properFormat = display ? `[[${display}]]` : `[[${link}]]`;
      return `<mark class="bg-highlight-200 dark:bg-highlight-800 text-highlight-900 dark:text-highlight-100 px-1 rounded-sm">${properFormat}</mark>`;
    }
    
    // Return the original match for non-relevant links
    return match;
  });
  
  // Then, process standard markdown links - convert to wikilink format and bold only the relevant link
  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, displayText, url) => {
    // Parse anchor if present
    const anchorIndex = url.indexOf('#');
    const baseUrl = anchorIndex === -1 ? url : url.substring(0, anchorIndex);
    
    // Extract the link text from URL to check if it matches target
    let linkText: string | null = null;
    if (baseUrl.startsWith('/posts/')) {
      linkText = baseUrl.replace('/posts/', '');
    } else if (baseUrl.startsWith('posts/')) {
      linkText = baseUrl.replace('posts/', '');
      // For folder-based posts, remove /index to get the folder name (slug)
      if (linkText && linkText.endsWith('/index')) {
        linkText = linkText.replace('/index', '');
      }
    } else if (baseUrl.endsWith('.md')) {
      linkText = baseUrl.replace(/\.md$/, '');
      // For folder-based posts, remove /index to get the folder name (slug)
      if (linkText && linkText.endsWith('/index')) {
        linkText = linkText.replace('/index', '');
      }
    } else if (!baseUrl.includes('/')) {
      linkText = baseUrl;
    }
    
    let isRelevantLink = false;
    
    if (linkText) {
      // Remove .md extension before slug generation
      const cleanLinkText = linkText.replace(/\.md$/, '');
      const linkSlug = cleanLinkText.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
      isRelevantLink = linkSlug === targetSlug;
    }
    
    // Also check if the display text matches the target post title
    if (!isRelevantLink) {
      const targetPost = posts.find(p => p.slug === targetSlug);
      if (targetPost) {
        const titleSlug = targetPost.data.title.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
        const displaySlug = displayText.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').replace(/^-+|-+$/g, '');
        isRelevantLink = displaySlug === titleSlug;
      }
    }
    
    // Convert markdown link to wikilink format: [Display](url) â†’ [[Display]]
    const wikilinkFormat = `[[${displayText}]]`;
    
    if (isRelevantLink) {
      // Highlight the wikilink format for the relevant link
      return `<mark class="bg-highlight-200 dark:bg-highlight-800 text-highlight-900 dark:text-highlight-100 px-1 rounded-sm">${wikilinkFormat}</mark>`;
    } else {
      // Keep as wikilink format but not highlighted
      return wikilinkFormat;
    }
  });
  
  return text;
}
---

{linkedMentions.length > 0 && (
  <section class="mt-12 pt-8 border-t border-primary-200 dark:border-primary-700">
    <button 
      id="linked-mentions-toggle"
      class="w-full text-left mb-6 flex items-center justify-between"
      aria-expanded="true"
      aria-controls="linked-mentions-content"
    >
      <div class="flex items-center">
        <Icon name="link-2" class="w-5 h-5 mr-2" />
        <h2 class="text-xl font-semibold text-primary-900 dark:text-primary-50">
          Linked Mentions
          <span class="ml-2 text-sm font-normal text-primary-500 dark:text-primary-400">
            ({linkedMentions.length})
          </span>
        </h2>
      </div>
      <span id="linked-mentions-arrow">
        <span id="linked-mentions-arrow-icon">
          <Icon 
            name="chevron-down" 
            class="w-5 h-5 text-primary-500 dark:text-primary-400" 
          />
        </span>
      </span>
    </button>
    
    <div id="linked-mentions-content" class="overflow-hidden transition-all duration-300 ease-in-out">
      {isCompact ? (
        <div class="space-y-2">
          {linkedMentions.filter(mention => mention !== null).map(mention => (
            <a 
              href={`/posts/${mention.slug}`}
              class="group flex items-center justify-between p-3 bg-primary-50 dark:bg-primary-800/30 rounded-lg border border-primary-200 dark:border-primary-700 hover:border-primary-300 dark:hover:border-primary-600 transition-colors block"
            >
              <span class="text-primary-900 dark:text-primary-50 group-hover:text-highlight-600 dark:group-hover:text-highlight-400 transition-colors font-medium">
                {mention.title}
              </span>
              <Icon name="arrow-right" class="w-4 h-4 text-white dark:text-primary-100 group-hover:text-highlight-600 dark:group-hover:text-highlight-400 transition-colors" />
            </a>
          ))}
        </div>
      ) : (
        <div class="space-y-4">
          {linkedMentions.filter(mention => mention !== null).map(mention => (
            <article class="p-4 bg-primary-50 dark:bg-primary-800/30 rounded-lg border border-primary-200 dark:border-primary-700 hover:border-primary-300 dark:hover:border-primary-600 transition-colors">
              <h3 class="font-medium text-primary-900 dark:text-primary-50 mb-2">
                <a 
                  href={`/posts/${mention.slug}`}
                  class="hover:text-highlight-600 dark:hover:text-highlight-400 transition-colors"
                >
                  {mention.title}
                </a>
              </h3>
              
              {mention.excerpt && (
                <p 
                  class="text-sm text-primary-600 dark:text-primary-300 leading-relaxed"
                  set:html={`...${processExcerptLinks(mention.excerpt, currentSlug)}...`}
                />
              )}
              
              <div class="mt-3 flex items-center text-xs text-primary-500 dark:text-primary-400">
                <Icon name="arrow-right" class="w-3 h-3 mr-1" />
                <span>Referenced in this post</span>
              </div>
            </article>
          ))}
        </div>
      )}
    </div>
  </section>
)}

<script>
  // Linked Mentions Toggle Functionality - Swup Compatible
  function initializeLinkedMentions() {
    const toggle = document.getElementById('linked-mentions-toggle') as HTMLButtonElement;
    const content = document.getElementById('linked-mentions-content') as HTMLElement;
    const arrowIcon = document.getElementById('linked-mentions-arrow-icon') as HTMLElement;
    
    if (toggle && content && arrowIcon) {
      // Remove any existing event listeners to prevent duplicates
      const newToggle = toggle.cloneNode(true) as HTMLButtonElement;
      const parentNode = toggle.parentNode;
      if (parentNode) {
        parentNode.replaceChild(newToggle, toggle);
      }
      
      // Get fresh references after cloning
      const freshContent = document.getElementById('linked-mentions-content') as HTMLElement;
      const freshArrowIcon = document.getElementById('linked-mentions-arrow-icon') as HTMLElement;
      
      // Add click handler to the new toggle element
      newToggle.addEventListener('click', function() {
        const isExpanded = newToggle.getAttribute('aria-expanded') === 'true';
        
        if (isExpanded) {
          // Collapse
          freshContent.style.maxHeight = '0';
          freshContent.style.opacity = '0';
          freshArrowIcon.style.setProperty('--arrow-rotation', '90deg');
          newToggle.setAttribute('aria-expanded', 'false');
        } else {
          // Expand
          freshContent.style.maxHeight = freshContent.scrollHeight + 'px';
          freshContent.style.opacity = '1';
          freshArrowIcon.style.setProperty('--arrow-rotation', '0deg');
          newToggle.setAttribute('aria-expanded', 'true');
        }
      });
      
      // Initialize with expanded state
      freshContent.style.maxHeight = freshContent.scrollHeight + 'px';
      freshContent.style.opacity = '1';
      freshArrowIcon.style.setProperty('--arrow-rotation', '0deg');
    }
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeLinkedMentions);
  } else {
    initializeLinkedMentions();
  }

  // Make function globally accessible for Swup hooks
  (window as any).initializeLinkedMentions = initializeLinkedMentions;
</script>

<style>
  /* Enhanced styling for linked mentions */
  .linked-mention-item {
    position: relative;
  }
  
  .linked-mention-item::before {
    content: '';
    position: absolute;
    left: -1rem;
    top: 0;
    bottom: 0;
    width: 3px;
    background: linear-gradient(to bottom, rgb(14 165 233), rgb(59 130 246));
    border-radius: 2px;
    opacity: 0.3;
  }
  
  .linked-mention-item:hover::before {
    opacity: 1;
  }
  
  /* Ensure smooth arrow transition */
  #linked-mentions-arrow-icon {
    display: inline-block;
    transition: transform 200ms ease-in-out !important;
    transform: rotate(var(--arrow-rotation, 0deg));
  }
</style>
